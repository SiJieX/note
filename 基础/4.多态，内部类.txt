多态：
	父类或者接口的引用指向其子类的对象（只要是其子类，因此有了多种形态）。
多态的好处：
	提高了代码的扩展性，（前期定义的代码可以使用后期的内容）
多态的弊端：
	不能使用其子类的特有功能
多态的前提：
	1，必须有关系，继承或实现。
	2，要有覆盖
转型:
	向上转型：父类 A = new 子类（）animal A = new Cat();
	向下转型：子类 A =(子类)（父类引用）Cat B =(Cat)A;
		为了访问子类特有功能
	注意：转型自始至终都是子类对象在做着转换，不能将父类对象转换为子类对象
instanceof
	用于判断对象的具体类型，只能用于引用类型变量
	格式：<对象 instanceof 类型> ，判断一个对象是否所属于指定的类型。
	返回值：ture/false
多态在子父类中的成员上的体现的特点：
	1.成员变量：在多态中，子父类成员变量同名
		编译时期：参考的是引用型变量所属的类中是否有调用的成员变量
		运行时期：也是参考引用型变量所属的类中是否有调用的成员
				成员变量 --- 编译运行都看 = 左边。 
	2.成员函数：
		编译时期：参考引用型变量所属的类中是否有调用的方法。
		运行时期：参考的是对象所属的类中是否有调用的方法。
			为什么是这样的呢？因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。
			简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。
			更简单：成员函数 --- 编译看 = 左边，运行看 = 右边。
	3.静态函数：
		编译时期：参考的是引用型变量所属的类中是否有调用的成员。
		运行时期：也是参考引用型变量所属的类中是否有调用的成员。
			为什么是这样的呢？因为静态方法，其实不所属于对象，而是所属于该方法所在的类。
			调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。
			简单说：静态函数 --- 编译运行都看 = 左边。
内部类（内置类，嵌套类）：
	1.内部类可以直接访问外部类中的成员
		因为内部类持有了外部类的引用：外部类.this
	2.外部类要访问内部类，必须建立内部类的对象
内部类定义的位置：
	1.外部类的成员位置
	2.外部类中的局部位置:
类不类修饰符：
	当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。
		1.默认修饰符（不写修饰符）
			其他类可以创建内部类对象：
				格式：外部类名.内部类名 变量名 = new 外部类对象.new 内部类对象();
					Outer.Inner in = new Outer.new Inner();这种形式很少用。
					这种形式很少用,因为内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。
		2：private
			通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。
		3：static
			如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。 
注意：
	1.内部类编译后的文件名为：“外部类名$内部类名.java”
	2.如果内部类中定义了静态成员，那么该内部类必须是静态的。
	2.静态方法里只能创建静态的内部类对象
局部内部类：
	内部类在外部类的方法里，或调用的方法里
		注意：内部类在局部位置上时只能访问局部中被final修饰的局部变量（成了常量）
匿名内部类：内部类的简写格式
	必须有前提：
		内部类必须继承或者实现一个外部类或者接口。
格式：
	new 父类/接口（）{子类内容}
使用场景之一：
	当函数参数是接口类型是，并且接口中的方法不超过三个时，可以用匿名内部类作为实际参数进行传递；
	当要用一个匿名内部类对象访问内部类中不同的方法时，可以用其继承的接口或父类来接收。但是这样就只能访问父类或接口的方法，不能访问子类的特有方法了（多态中的向上转型）

















	
	