面向对象的特征：封装，继承，多态
	开发的过程：其实就是不断的创建对象，使用对象，指挥对象做事情。
	设计的过程：其实就是在管理和维护对象之间的关系.
类类型变量：Car c = new 构造方法();c就是类类型引用变量
		类类型的变量一定指向对象，要不就是null
		打印c结果是包名+@+地址
测试类：
	用来测试其他类的成员
	一般测试类才写main方法
成员变量：定义在类中的变量(一般不初始化)
局部变量：定义在方法中的变量
成员变量与局部变量的区别：
	1.在类中的位置不同
		成员变量：类中，方法外
		局部变量：在方法中或方法声明上（形式参数）
	2.应用范围：
		成员变量在整个类中有效
		局部变量只在其声明的方法内有效（在相应的作用域有效）
	3.生命周期：
		成员变量随着对象的创建而创建，随着对象的消失而消失
		局部变量使用完立即释放
	4.存储位置：
		成员变量存储在堆内存中，当没有引用指向时，被垃圾回收机制回收
		局部变量存储在栈内存中，执行完毕，马上消失
	5.初始值
		成员变量有默认初始值
			1.整数byte、short、int、long =0；
			2.double,float:0.0;
			2.char='\uoooo'；
			3.boolean =flase；
			4.String =null;
			5.类类型 =null；
			6.数组 =null；
			
		局部变量必须手动初始化
			 必须给初始化值，没有初始值，不能使用
private:
	1.只能修饰成员
	2.被private修饰的成员只能在本类中使用

匿名对象：
	没有名字的实体，就是没有对应的变量名的引用。
匿名对象的用途：
	1.当对象对方法只进行一次调用时，运用可以简化代码（不采用匿名对象调用成员属性，因为没有意义）
	2.匿名对象可做实际参数进行传递
封装：
	隐藏对象的属性和实现细节，仅对外提供公共的访问方式
封装的特性：
	安全性：将成员属性用private修饰（私有的内容只在本类中有效），然后对外提供get和set方法，在方法里实现，符合要求的成员属性
	将变化隔离：只要知道怎么使用，具体是怎么实现的并不知道
	便于使用：直接调用封装好了的封装体
	提供重复性：可以重复使用
封装的原则：
	将不需要对外提供的内容都封装起来。
	把属性都隐藏起来，提供公共方法对其访问。
		注意：私有仅仅是封装的一种体现形式，不私有也可以封装。
		      java中最小的封装是函数。类，框架就是封装体。
		      private只能修饰成员,修饰构造函数时，只能自己创建本类对象。
构造函数：构建创造对象时调用的函数，
		作用：给对象进行初始化（创建对象都必须要通过构造函数初始化）
		格式：public 类名（参数列表）函数名与类名一致，没有返回值。（不能写void，不加public只能包内可见）
构造函数与普通函数的区别：
	1.调用时间：构造函数是对象创建时由jvm调用。一般函数是对象创建后需要函数功能时由对象调用
	2.调用次数：构造函数在对象创建时只调用一次。一般函数在对象创建后可以多次调用
什么时候定义构造函数：
	在描述事物时，该事物一存在就具备的一些内容，这些内容都定义在构造函数中。
构造代码块：
	{
	}
	作用:给所有对象进行初始化，（构造函数是给特点对象进行针对性的初始化）
		构造代码块是在类下面，在函数里面的代码块为局部代码块。
	应用场景：可以将构造函数里的共同代码，抽取到构造代码块里。
	
注意：		
	1.当类中没有定义构造函数时，系统会给该类加一个空参数的默认构造函数，当类中如果自定义了构造函数，默认的构造函数就没有了。
		建议：当重载了构造函数后，写上无参数的构造函数。
	2.一个类中可以定义多个构造函数（参数不一样），多个构造函数是以重载的形式体现的	
	3.构造函数里可以调用该类中的其他构造方法或一般方法，类中的一般方法不可以调用构造函数。
	4.构造函数前不能加void,虽然不会报错但是会成为一般方法。
	5.构造函数里调用类中其他构造函数格式为this(参数)不能写成this.类名（参数）应为构造函数是对象初始化时调用，对象还没有被创建。
	6.成员变量先显示初始化后，在构造函数里进行显示初始化。
this关键字：
	this代表其所在函数所属对象的引用。
	作用：
		1：构造函数里调用其他构造函数：this(参数)。不能写成this.类名（参数）
			-构造函数里调用其他构造函数时只能放在构造函数的第一行，否则编译报错
			-递归构造函数调用：构造函数的相互调用。编译时期会报错
		2：解决构造函数中对象属性和函数形参重名的问题
			没有重名时可以省略this
		3：在set,get方法中局部变量和成员变量重名时，会使用就近原则，就不会赋值给成员变量，这时有this代替本类对象的引用
		4：多线程同步函数的锁使用的就是this

	注意：1.this只能在非静态中（没有static修饰的）函数里使用（因为this是在创建对象时才会出现）
	      
		