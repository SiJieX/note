static关键字：
	-是一个修饰成员的修饰符
	-修饰的成员被所有对象所共享

static特点：
	1.优先于对象存在，static修饰的成员随着类的加载而存在
	2.修饰的成员多了一种调用方式，可以直接被类名所调用。类名.静态成员
	3.修饰的数据是共享数据，对象中存储的是特有数据
什么时候用静态：
	1.静态变量
		当分析对象中所具备的成员变量的值是相同的。
	2.静态函数
		该函数的功能是否访问到对象中的特有数据，
		从代码看就是，该功能是否需要访问非静态的成员变量，如果没访问到就用静态修饰
静态代码块：
	static{
	}
	随着类的加载而加载，且执行一次
作用：
	用于给类进行初始化，主要是方便一些运算。
	注意：当一个类中有主函数，静态代码块比主函数先执行。（因为类一加载就执行）

成员变量和静态变量的区别：
	1.周期不同
		成员变量是随着对象的创建而存在的，随着对象的回收而释放
		静态变量随着类的加载而加载，随着类的消失而消失（虚拟机的关闭）
			类也是一个对象，java中有内存优化机制，当类在方法区中过多时，控制类的对象会释放多余的类。
			静态变量虽然生命周期长，但是可以节约内存空间	
	2.调用方式不同：
		成员变量只能被对象调用
		静态变量可以被对象调用，也可以被类名调用（建议用类名调用，因为用类名调用，就省去了创建对象的过程）
	3.数据存储位置不同
		成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据
		静态变量数据存储在方法区（也叫共享数据区）的静态区，所以也叫对象的共享数据
注意：
	1.静态方法只能访问静态成员，非静态即可访问静态，也可访问非静态。
	2.静态方法中不可以使用this和super关键字
	3.主函数是静态的
	4.静态修饰属性的值，可以改变
单例设计模式：
	保证一个类在内存中对象的唯一性。
	例如：多个应用程序使用同一个配置信息对象时，就需要保证对象的唯一性。
如何保证对象的唯一性：
	1.不允许其他程序用new创建对象
	2.在该类中创建一个本类实例
	3.对外提供一个方法让其他程序可以获取对象。
继承特点：
	1.描述类和类之间的关系
	2.降低类和类之间的重复代码（降低对象和对象之间的重复代码用静态变量）
	3.提高代码的可扩展性（覆盖父类的方法，然后添加新功能）
	弊端：
		打破了封装性
单继承：
	一个子类只能有一个直接父类
多继承：
	一个子类可以有多个直接父类（java不支持，进行了改良，在java中是通过多实现来体现的）
		缺点：如果多个父类中有相同成员，会产生调用的不确定性
super关键字作用
	1：主要存在于子类方法中，用于指向子类对象中父类对象。
	2：访问父类的属性
	3：访问父类的函数（覆盖）格式：super.父类方法名（参数列表）
	4：访问父类的构造函数
		在子类的所有构造函数中的第一行都有一个隐式的super（）调用的是父类的空参数构造函数。
			为什么子类在实例化的时候要访问父类的构造函数：
				子类继承了父类，获取了父类的成员属性，所以在使用父类的内容是，要先看父类是怎样初始化父类的属性。
		注意：1.如果父类中没有定义空参数的构造函数，子类的构造函数中必须用super语句确定要调用父类中的哪个构造函数。
		      2.如果子类的构造函数中用this关键字调用了本类中的其他构造函数，就没有super语句了，但是可以确定其他构造函数中有super语句。
		      3.子类中的super语句必须放在构造函数的第一行。因为父类的初始化要先完成。
		      4.所以类中的构造函数都有隐式的super语句，因为所以类都继承了object类
		      5.父类构造函数里有调用同名的子父类方法时会执行子类方法
		      6.成员变量默认初始化后，在构造函数里进行显示初始化
super和this的区分:
	1.当子父类中的成员变量重名，用super区分
	  当本类中的成员属性与局部变量重名有this区分
	2.this代表一个本类对象的引用
	  super代表一个父类空间（子在堆里的对象分配了一个父类的空间）
函数的两个特性：
	覆盖（重写或复写或override）：
		当子父类中出现成员函数一模一样的情况（返回值类型一样，函数名相同，参数列表相同）会运行子类的函数
		注意：1.子类方法覆盖父类方法时子类的权限必须大于或等于父类方法的权限
		      2.父类的权限为private时就不是覆盖了。
		      3.当被static修饰时，子类要想覆盖父类中的一模一样的方法时，都要被static修饰。
	重载：在同一个类中
什么时候使用覆盖操作：
	当对一个类进行子类功能的扩展时，子类需要保留父类的原有的功能时，同时需要进行添加新功能时，就需要覆盖操作。
	在子类的覆盖方法中写上  super.方法名
注意：1.子类并不能继承父类中所有的成员（被private修饰的成员不能继承）
	被private修饰后的成员，子类不能访问，但是可以通过间接得get和set方法访问
final关键字：
	可以修饰类，方法，变量。
		final修饰的类不可以被继承（为了数据的安全性）
		final修饰的方法不可以被覆盖（为了数据的安全性）
		final修饰的变量是一个常量，只能赋值一次（一般都会再加static修饰）
			原因：为了阅读性，和方便使用



	
	

